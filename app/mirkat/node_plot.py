import random
import string

from altair import Chart
from langchain_core.messages import ( 
    AIMessage
    )
from google.genai import types
from google.genai import Client
from dotenv import load_dotenv
from app.mirkat.plot_functions import PlotFunctons
import base64
import io, os
from app.mirkat.global_variables import SQL_QUERIES
from app.mirkat.node_constructor import node
import json


load_dotenv()

# Get the API key
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")

class PlotNode(node):
    def __init__(self, llm=None, instructions=None, functions=None,  welcome=None):
        super().__init__(llm, instructions, functions, welcome, logging_key="Plot node.- ")
        self.client = Client(api_key=GOOGLE_API_KEY)
        self.schema = {
            "type": "object",
            "properties": {
                "caption": {"type": "string"},
                "code": {"type": "string"},
                "notes": {"type": "string"}
            },
            "required": ["caption", "code"]
        }
        self.set_model()


    def set_model(self):
        config_with_code = types.GenerateContentConfig(
            temperature=0.0,
            system_instruction= self.instructions,
            response_schema= self.schema,
            response_mime_type="application/json",
            max_output_tokens=500,
        )
        self.model = self.client.chats.create(model=self.llm, config=config_with_code)

    def run_model(self, messages):
        """Run the model with the given messages."""
        #print(f"--- Message going to the llm_master: {messages}---")
        self.log_message(f"Message going to the node: {messages}")
        inner_tries = 1
        while inner_tries <= 2:
            try:
                response_plot = self.model.send_message(messages)
                inner_tries = 2
            except Exception as e:
                if inner_tries < 2:
                    self.log_message(f"Error sending message to Plot model: {e}. Rennuning for {inner_tries} time")
                else:
                    self.log_message(f"Error sending message to Plot model: {e}. No more retries.")
                    raise e
            finally:
                inner_tries = inner_tries + 1

        return response_plot
    
    def handle_response(self, response_plot):
        plotting_tools_instance = PlotFunctons('', response_plot)
        plotting_tools_instance.handle_response()

    def run_code_plot(self, code):
        """
        This function will take the code generated by the model and plot it.
        """
        loc = {}
        exec(code, globals(), loc)
        return_workaround = loc['figure'] if 'figure' in loc else None
        return return_workaround

    def extract_response(self, response_plot):
        """
        This function will take the answer and proceed to convert to json
        """
        response_json = response_plot
        if isinstance(response_plot, str):
            response_json = json.loads(response_plot)
        return response_json

    def get_node(self, state):
        messages = state['request']
        self.log_message(f"Messages received in PlotNode: {messages}")
        queries = SQL_QUERIES # state['table']

        response_plot = self.run_model(str(queries) + messages.content)
        response_json = self.extract_response(response_plot=response_plot.text)
        code = response_json["code"]
        self.log_message(f"Running code {code}")
        plot = self.run_code_plot(code)
        note = response_json["notes"]
        answer = response_json["caption"]

        answer_b = answer
        name = "not_generated"
        if plot:
            buf = io.BytesIO()
            if not isinstance(plot, Chart):
                plot.savefig(buf, format='png') # Or another format like 'jpeg'
                name = "plot_" + ''.join(random.choices(string.ascii_letters + string.digits, k=10)) + ".svg"
                plot.savefig(name, format = 'svg')
            elif isinstance(plot, Chart):
                plot.save(buf, format='json')
            buf.seek(0)
            image_base64 = base64.b64encode(buf.read()).decode('utf-8')
            buf.close()
            # response_plot.candidates[0].content.parts[0].text =  f"binary_image: {image_base64}"
            answer_b = answer + f" <image>{name}</image>"
            answer = answer_b + " using code: " + code
        history = state.get("history", [])
        return {**state,
                "messages": AIMessage(content=""),
                "answer": AIMessage(content=answer_b),
                "request": AIMessage(content=note + answer_b),
                "answer_source": 'PlotNode',
                "trys": state.get("trys", 0) + 1,  # Use .get for safety
                "history": history + [AIMessage(content=answer)], # Update history with the new message
            }
    
    
